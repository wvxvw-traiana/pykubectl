* Why?
  I wish more people would ask this question before starting new
  programming projects!  I seriously do!

  Here's a short parable of sorts.  It will tell you why this project
  was started and what its goals are.

** Excitement
   One day your boss walks into the office and proudly proclaims: ``We
   are now doing micro-services.  Effective immediately.''  This
   lights the spark of excitement in you.  You've already heard about
   micro-services.  The micro-services fashion movement had already
   sent its missionaries to charm you.  At the long last, your boss
   has also converted.  Of course, you select the best tool to deploy
   micro-services: Kubernetes.  Let me spell it out for you:
   =K      U      B      E      R      N      E      T      E      S=
   What a joy!

** Questioning
   After working for a while with the Kubernetes you run into a bug.
   A small issue really, it only took you about a day to figure out it
   was a bug, and not your misreading of documentation.  It appears
   that if you refer to a service from the container hosting the
   service by the name you specified for the service... it won't work.

   What's next?--Still excited by the fact you are using Kubernetes,
   you rush to create a new ticket on the Kubernetes GitHub page.
   And here you get the first glimpse of sobering reality.  There are
   about 60000 (sixty thousands) tickets this project collected in a
   few years it's been worked on.

** Doubt
   With a trembling pen in hand you fill out the lengthy ticket form
   only to be closed later as duplicate of some other lengthy ticket
   form with lenghty discussion and obscure references.

** Denial
   You wipe a single manly tear just about to drop on your keyboard,
   open up a readme and type: ``Limitations:''--You sigh heavily--
   ``Calling a service from inside container...''

** Excitement
   Yey!  Problem solved!

** Oy-Vey!
   Your boss steps into the office once again, happier than ever:
   --Listen folks--he says,--Why don't we connect this Kubernetes
   thing we have to this other thing we have?  You know, it should be
   fun!

** Ingenuity
   I belive ``ingenuity'' should be spelled with ``e'': ``enginuity''.
   Who if not engineers are to excell in it?

   Anyways.  All you did so far with Kubernetes was done by the handy
   tool: =kubectl=.  It wasn't that hard.  Type a few simple commands
   and watch a whole bunch of containers and services spring into
   existence!  It will be a walkin in the park you think.  I'll just
   do what =kubectl= does from a script.

*** It Doesn't Work
    Well, you are not allowed to use =kubectl= because you cannot
    guarantee it will be installed on target computer.  Bummer.
    You resort to writing a script that uses HTTP API.

*** It Doesn't Work
    Well, the HTTP API is nothing like =kubectl=.  It's a book with
    overwhelming amount of details and no general concept to rule them
    all.  It's impossible that nobody had already dealt with this
    problem before: there must be already an API client in your
    language.  You resort to finding that client.

*** It Doesn't Work
    Well, there is an official client.  It is autogenerated from the
    horrible HTTP API and mirrors it one-to-one.  It's documentation
    was also automatically generated and is of no real use.  You
    resort to finding an alternative client.

*** It Doesn't Work
    Well, now you found two other clients.  They are better, but they
    don't implement the API fully, and they don't offer the necessary
    level of generality.  You still need to parse configuration files
    =kubectl= already knows how to parse.  You still need to put small
    pieces together where =kubectl= would've done this work for you.

*** It Sort of Does
    Finally, you find another poor soul, who was with you all this
    time, albeit in virtual world.  This poor sould decided to wrap
    calls to =kubectl= in Python.  The problem is: you need =kubectl=
    installed.

*** Duct Tape
    Being an engineer, you roll up your sleevs, pull out your trusty
    roll of duct tape and get busy.  It's not easy because there isn't
    really a way to generate Python 3 bindings straight out of Go
    code.  You need to go through CGo, and then CGo cannot deal with
    all types of Go values (in fact, only the few basic ones are
    supported).  And then you need to go through C: write the glue
    code in C, to bridge between =kubectl= code and... no, this isn't
    Python yet.  Writing Python C code by hand will make your eyes
    bleed.  So you roll out a run of duct tape and glue one end to Go,
    the other hand to CGo.  You repeat the same thing for CGo and C.
    C and Cython.  Cython and Python.  You roll the duct tape about
    incompatibilities on call conventions, linkers API, shared
    libraries location mechanics...

    The implementation of =kubectl= is the last straw.  Another
    engineer with tons of duct tape already worked on it.  You add
    some more to make it compile.  Then you add some more to expose
    some functionality.  And this is why this project was born.

    Read below for instruction for duct tape application.  I'm sure
    you will need it!

* Apply With Care
  - Download Kubernetes code
  - Download Go compiler
  - Tinker with Go compiler until Kubernetes code compiles.
    + Create =k8s.io= directory in your =GOPATH=.
    + Symlink =kubernetes/vendor= directory to =kubernetes/vendor/src=
    + Symlink =apimachiner=, =paiserver= and =kubernetes= into
      =k8s.io=.
    + Cross your fingers.
    + Prey.
    + Prey.
    + Prey.
    + Uncross your fingers.
    + Try different Go compiler.
    + Try ~export GODEBUG=cgocheck=0~ (though it's probably unrelated).
    + Cross your fingers.
    + Prey.
    + Prey more.
  - Compile Go code of this project:
    #+BEGIN_SRC sh
      go build -buildmode=c-shared -o pykubectl \
         github.com/wvxvw-traiana/pykubectl/main
    #+END_SRC
  - Copy this library into =/usr/local/lib=. (I'll automate this part
    later).
  - Install Python dependencies:
    #+BEGIN_SRC sh
      pipenv install --dev
    #+END_SRC
    This implies you already have Python and =pipenv=.
  - Make sure you have GCC installed.
  - Install Python package:
    #+BEGIN_SRC sh
      sudo ./setup.py install
    #+END_SRC
    This will also install example script =pykubectl= to help you
    verify that the process succeeded.
  - Run =pykubectl=.  You should either see a formatted Python =dict=
    with details from the pods in your cluster, or an error explaining
    why the connection to your cluster failed.  If you see something
    else, try steps above one more time.  You can also try requesting
    my help.  I like helping people.
